      subroutine ODEINT(YSTART, NVAR, X1, X2, EPS, H1, HMIN, NOK, NBAD, 
     .             DERIVS, RKQC)
c*****************************************************************************
c     Runge-Kutta driver with adaptive stepsize control.  Integrate the
c     NVAR starting values YSTART from X1 to X2 with accuracy EPS, storing
c     intermediate results in the common block /PATH/.  H1 should be set
c     as a guessed first stepsize, HMIN as the minimum allowed stepsize
c     (can be zero).  On output NOK and NBAD are the number of good and bad
c     (but retried and fixed) steps taken, and YSTART is replaced by values
c     at the end of the integration interval.  DERIVS is the user-supplied
c     subroutine for calculating the right-hand side derivative, while RKQC
c     is the name of the stepper routine to be used.  PATH contains its own
c     information about how often an intermediate value is to be stored.
c*****************************************************************************

      PARAMETER  (MAXSTP = 10000, NMAX=10, TWO=2.0, ZERO=0.0, TINY=1.e-30)
      COMMON /PATH/ KMAX, KOUNT, KXSAV, XP(200), YP(10,200)
c           USER STORAGE FOR INTERMEDIATE RESULTS.  PRESET DXSAV AND KMAX

      DIMENSION YSTART(NVAR), YSCAL(NMAX), Y(NMAX), DYDX(NMAX)
      X=X1
      H=SIGN(H1,X2-X1)
      NOK=0
      NBAD=0
      KOUNT=0
      do I=1,NVAR
          Y(I)=YSTART(I)
      enddo
      XSAV=X-DXSAV*TWO
      do NSTP=1,MAXSTP
          CALL DERIVS(X,Y,DYDX)
          do I=1,NVAR
              YSCAL(I)=ABS(Y(I))+ABS(H*DYDX(I))+TINY
          enddo
          IF (KMAX.GT.0) THEN
              IF (ABS(X-XSAV).GT.(DXSAV)) THEN
                  IF (KOUNT.LT.KMAX-1) THEN
                      KOUNT=KOUNT+1
                      XP(KOUNT)=X
                      DO I=1, NVAR
                          YP(I,KOUNT)=Y(I)
                      ENDDO
                      XSAV=X
                  ENDIF
              ENDIF
          ENDIF

          IF ((X+H-X2)*(X+H-X1).GT.ZERO) H=X2-X
          CALL RKQC(Y,DYDX,NVAR,X,H,EPS,YSCAL,HDID,HNEXT,DERIVS)
          IF(HDID.EQ.H)THEN
              NOK=NOK+1
          ELSE
              NBAD=NBAD+1
          ENDIF
          IF( (X-X2)*(X2-X1).GE.ZERO)THEN
              DO I=1,NVAR
                  YSTART(I)=Y(I)
              ENDDO
              IF(KMAX.NE.0)THEN
                 KOUNT=KOUNT+1
                 XP(KOUNT)=X
                 DO I=1,NVAR
                     YP(I,KOUNT)=Y(I)
                 ENDDO
              ENDIF
              RETURN
          ENDIF
          IF (ABS(HNEXT).LT.HMIN) PAUSE 'Stepsize smaller than minimum.'
          H=HNEXT
      enddo
      PAUSE 'Too many steps!'
      RETURN
      END

      SUBROUTINE LINTERPOLATE(X_OLD, Y_OLD, X_NEW, Y_NEW)
      DO I=1,NTAU-1
          IF X_OLD[I+1].GE.X_NEW THEN
              EXIT
      ENDDO
      SLOPE = (Y_OLD(I+1)-Y_OLD(I))/(X_OLD(I+1)-X_OLD(I))
      Y_NEW = Y_OLD(I)+SLOPE*(X_NEW-X_OLD(I))
      RETURN
      END

      SUBROUTINE DERIVS(X,Y,DYDX)
C*****************************************************************************
C     This subroutine calculates the derivatives of the stokes parameters at
C     Tau = X.
C*****************************************************************************
      CALL LINTERPOLATE(TAULAM, ETA_I, 10.0**X, EI)
      CALL LINTERPOLATE(TAULAM, ETA_Q, 10.0**X, EQ)
      CALL LINTERPOLATE(TAULAM, ETA_V, 10.0**X, EV)
      CALL LINTERPOLATE(TAULAM, T, 10.0**X, TEFF)

      CALL PLANCK(WAVE,TEFF, B)

      DYDX(1) = (1.0+EI)*Y(1)+EQ*Y(2)+EV*Y(3) - (1.0+EI)*B
      DYDX(2) = EQ*Y(1)+(1.0+EI)*Y(2) - (EQ)*B
      DYDX(3) = EV*Y(1)+(1.0+EI)*Y(3) - (EV)*B
      DYDX(4) = Y(4)-B
      RETURN
      END

      SUBROUTINE RKQC(Y,DYDX,N,X,HTRY,EPS,YSCAL,HDID,HNEXT,DERIVS)
c*****************************************************************************
c     Fifth-order Runge-Kutta step with monitoring of local truncation error
c     to ensure accuracy and adjust stepsize.  Input are the dependent
c     variable vector Y of length N and its derivative DYDX at the starting
c     VALUE of the independent variable X.  Also input are the stepsize to
c     be attempted HTRY, the required accuracy EPS, and the vector YSCAL
c     against which the error is scaled.  On output, Y, and X are replaced by
c     their new values, HDID is the stepsize which was actually accomplished,
c     and HNEXT is the estimated next stepsize.  DERIVS is the user-supplied
c     subroutine that computes the right-hand side derivatives.
c*****************************************************************************
      PARAMETER (NMAX=10,PGROW=-0.20,PSHRINK=-0.25,FCOR=1./15.,ONE=1.,
     .          SAFETY=0.9,ERRCON=6.e-4)
c          THE VALUE ERROCON EQUALS (4/SAFETY)**(1/PGROW)
      EXTERNAL DERIVS
      DIMENSION Y(N),DYDX(N),YSCAL(N),YTEMP(NMAX),YSAV(NMAX),DYSAV(NMAX)
      XSAV=X
      DO I=1,N
          YSAV(I)=Y(I)
          DYSAV(I)=DYDX(I)
      ENDDO
C        SET STEPSIZE TO THE INITIAL TRIAL VALUE
      H=HTRY
C        TAKE TWO HALF STEPS
1     HH=0.5*H
      CALL RK4(YSAV,DYSAV,N,XSAV,HH,YTEMP,DERIVS)
      X=XSAV+HH
      CALL DERIVS(X YTEMP,DYDX)
      CALL RK4(YTEMP,DYDX,N,X,HH,Y,DERIVS)
      X=XSAV+H
      IF(X.EQ.XSAV)PAUSE 'STEPSIZE NOT SIGNIFICANT IN RKQC'
C          TAKE THE LARGE STEP
      CALL RK4(YSAV,DYSAV,N,XSAV,H,YTEMP,DERIVS)
C          EVALUATE ACCURACY
      ERRMAX=0
      DO I=1,N
C          YTEMP NOW CONTAINS THE ERROR ESTIMATE
          YTEMP(I)=Y(I)-YTEMP(I)
          ERRMAX=MAX(ERRMAX,ABS(YTEMP(I)/YSCAL(I)))
      ENDDO
C          SCALE TO RELATIVE TO REQUIRED TOLERANCE
      ERRMAX=ERRMAX/EPS
      IF(ERRMAX.GT.ONE)THEN
C          TRUNCATION ERROR TOO LARGE, REDUCE STEPSIZE, TRY AGAIN
          H=SAFETY*H*(ERRMAX**PSHRINK)
          GOTO 1
      ELSE
C          STEP SUCCEEDED.  COMPUTE SIZE OF NEXT STEP
          HDID=H
          IF(ERRMAX.GT.ERRCON)THEN
              HNEXT=SAFETY*H*(ERRMAX**PGROW)
          ELSE
              HNEXT=4.*H
          ENDIF
      ENDIF
      DO I=1,N
          Y(I)=Y(I)+YTEMP(I)*FCOR
      ENDDO
      RETURN
      END

      SUBROUTINE RK4(Y,DYDX,N,X,H,YOUT,DERIVS)
c*****************************************************************************
c     Given values for N variables Y and their derivatives DYDX known at X,
c     use the fourth-order Runge-Kutta method to advance the solution over an
c     interval H and return the incremented variables as YOUT, which need not
c     be a distinct array from Y.  The user supplies supplies the subroutine
c     DERIVS(X,Y,DYDX) which returns derivatives DYDX at X.
c*****************************************************************************

      PARAMETER (NMAX=10)
      DIMENSION Y(N),DYDX(N),YOUT(N),YT(NMAX),DYT(NMAX),DYM(NMAX)
      HH=H*0.5
      H6=H/6.
      XH=X+HH
C          FIRST STEP
      DO I=1,N
          YT(I)=Y(I)+HH*DYDX(I)
      ENDDO
C         SECOND STEP
      CALL DERIVS(XH,YT,DTY)
      DO I=1,N
          YT(I)=Y(I)+HH*DYT(I)
      ENDDO
C         THIRD STEP
      CALL DERIVS(XH,TY,DYM)
      DO I=1,N
          YT(I)=Y(I)+H*DYM(I)
          DYM(I)=DYT(I)+DYM(I)
      ENDDO
C         FOURTH STEP
      CALL DERIVS(X+H, YT, DYT)
      DO I=1,N
          YOUT(I)=Y(I)+H6*(DYDX(I)+DYT(I)+2.*DYM(I))
      ENDDO
      RETURN
      END
